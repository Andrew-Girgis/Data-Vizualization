---
title: "STAT 442: Assignment 1"
subtitle: "DUE: Wednesday January 29 by 11:59pm EST"
output:
  pdf_document:
    keep_tex: yes
    number_sections: no
  html_document:
    toc: yes
  word_document: default
urlcolor: blue
---



```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

```{r, include = FALSE}
library(knitr)
#opts_chunk$set(tidy.opts=list(width.cutoff=70),tidy=TRUE)
```

$\;$
$\;$
$\;$
$\;$

## NOTES

This assignment has three parts - One reading assignment and two programming questions. 

Your assignment must be submitted by the due date listed at the top of this document, and it must be submitted electronically in .pdf format via Crowdmark. 

This means that your responses for different question parts should begin on separate pages of your .pdf file. Note that your .pdf solution file must have been generated by R Markdown. Additionally:

Organization and comprehensibility is part of a full solution. Consequently, points will be deducted for solutions that are not organized and incomprehensible. Furthermore, if you submit your assignment to Crowdmark, but you do so incorrectly in any way (e.g., you upload your Question 2 solution in the Question 1 box), you will receive a 5% deduction (i.e., 5% of the assignmentâ€™s point total will be deducted from your point total).

\newpage

# Part 1 - Reading: Evaluating Effects of Background Stories on Graph Perception [12 marks, 2 marks each]


Read the first 7 pages of the article "Evaluating Effects of Background Stories on Graph Perception" by Ying Zhao et al. and answer the following questions. Each answer should be at MOST one or two sentences, and you may copy directly from the source article without citing.

a) What is the difference between a graph (any type of visualization) and a graph (visualization of a network)?

b) In the context of this article, what is a UBSer and an FBSer?

c) What is one of the three hypotheses that the article explores about background stories? (Quoting any one of the three is fine)

d) What is a metric proposed for graph readability?

e) What is the name that the article uses for the context of the graph that is not shown in the graph. In other words, the "missing datapoints that are in our head", or the "exformation"?

f) What are the three types of graph structures that the participants were asked to identify in one of the experiments?



\newpage

# Part 2 - Make a tier list [16 marks]

(16 marks) A client wants a function to make a tier list in R, like the following, but with text instead of images. (Credit to Tierzoo for this tierlist)

![](open_ocean_tierzoo.png)

Make a function called `tierlist` and fill in the following template.


```{r}
plot.new()
x_left = 0
X_right = 10
y_bottom = 0
y_top = 10
plot.window(xlim=c(x_left,X_right), ylim=c(y_bottom, y_top))


tiernames=c("S","A","B","C","D","F")

Ntiers = length(tiernames)

tiercols = c("lightblue","green", "lightgreen", "yellow", "orange", "red")

tier_start_y = y_top * 0.9
# take 10% off the top for the title

tier_start_x = ((X_right-x_left) * 0.1 + x_left)
# Starts 10% to the right to leave space for the tier label

space = (tier_start_y-y_bottom)/Ntiers
# Divide the space into equal parts of the window

tier_height = (space) * 0.9
# height of the tiers minus 10% for the gaps

rect(x_left, y_bottom, X_right, y_top, col = "black")
text((X_right+x_left)/2, y_top * 0.95, labels = "Tierlist", col = "white")

title = "Ice Cream Tier List"
tier = c("S","S","A","A","B","B","B","C","D","F")
text = c("Dolce de Leche", "Strawberry",
         "Vanilla", "Mint", 
         "Chocolate", "Spumoni", "Sherbet",
         "Rocky Road", "Butter Rum", "Raisin")

df = data.frame(tier, text)

tier_counts <- table(df$tier)


for (i in 1:Ntiers)
{
  this_df = subset(df, tier == tiernames[i])
  Nboxes = nrow(this_df)
  if (i>1)
  {
  tier_start_y = tier_start_y - (space)
  rect(tier_start_x, tier_start_y - tier_height, X_right * 0.95, tier_start_y, col = tiercols[i])
  text((x_left + tier_start_x)/2, ((tier_start_y - tier_height) + tier_start_y)/2, tiernames[i], col = tiercols[i] )
    for (j in 1:Nboxes)
    {
      cent = (((X_right * 0.95) - tier_start_x) / (Nboxes + 1))
      x_pos = tier_start_x + cent * j
      y_pos = ((tier_start_y - tier_height) + tier_start_y) / 2
      
      # Draw a white box behind the text
      rect(x_pos - 1, y_pos - 0.5, x_pos + 1, y_pos + 0.5, col = "white", border = NA)
      
      # Add the text on top of the white box
      text(x_pos, y_pos, df$text[df$tier == tiernames[i]][j])
      
    }
  } else {
    rect(tier_start_x, tier_start_y - tier_height, X_right * 0.95, tier_start_y, col = tiercols[i])
    text((x_left + tier_start_x)/2, ((tier_start_y - tier_height) + tier_start_y)/2, tiernames[i], col = tiercols[i] )
       for (j in 1:Nboxes)
    {
      cent = (((X_right * 0.95) - tier_start_x) / (Nboxes + 1))
      x_pos = tier_start_x + cent * j
      y_pos = ((tier_start_y - tier_height) + tier_start_y) / 2
      
      # Draw a white box behind the text
      rect(x_pos - 1, y_pos - 0.5, x_pos + 1, y_pos + 0.5, col = "white", border = NA)
      
      # Add the text on top of the white box
      text(x_pos, y_pos, df$text[df$tier == tiernames[i]][j])
      
    }
  }
}

```


```{r, eval=FALSE}
tierlist = function(df, tiernames=c("S","A","B","C","D","F"), 
                    tiercols = c("lightblue","green", "lightgreen", "yellow", "orange", "red"),
                    main="My Tier List")
{
 # background
  rect(...)

  # Main title
  text(...)
       
  Ntiers = length(tiernames)

  # find the bar bounds
  bar_bounds_y = ...
  ...
  
  # draw the bars
  for(k in 1:Ntiers)
  {
    rect(...)
  }
  
  # draw the tier labels
 ...
 
  # find the box bounds and draw the boxes
  for(k in 1:Ntiers)
  {
    this_df = subset(df, tier == tiernames[k])
    Nboxes = nrow(this_df)
    box_bounds_left = ...
    
    for(j in 1:Nboxes)
    {
      ...
    }
  }
  
}
```

that does the following

- Draws a black background with rectangles for each of the tiers described by `tiernames` and `tiercols`.
- Draws a main title in white text described in `main` above the rectangles.
- Takes in a dataframe `df` that has a `tier` variable and `text` variable.
- For each row of `df`, makes a white box in the appropriate tier and fills it with the black text in `text`.
- Each bar should have room for four boxes, but only filled boxes should be draw

Test your function with this code

```{r, eval=FALSE}

title = "Ice Cream Tier List"
tier = c("S","S","A","A","B","B","B","C","D","F")
text = c("Dolce de Leche", "Strawberry",
         "Vanilla", "Mint", 
         "Chocolate", "Spumoni", "Sherbet",
         "Rocky Road", "Butter Rum", "Raisin")

df = data.frame(tier, text)

plot.new()
plot.window(xlim=c(0,10), ylim=c(0,10))
tierlist(df, tiernames=c("S","A","B","C","D","F"), 
                    tiercols = c("lightblue","green", "lightgreen", "yellow", "orange", "red"),
                    main=title)
```


\newpage


# Part 3 - Write a Four-way Venn Diagram function [16 marks]


A client wants a function to make a standard four-way Venn diagram, like one of the following:

![](Venn1.png)


![](Venn3.jpeg)

a) (8 marks) Make a function called `venn.oval` using the following

```{r, eval=FALSE}
venn.oval = function(centerxy = c(0,0), longxy = c(2,-2), 
                 shortxy = c(1,1), col="#FFFFFF")
{
  # You fill this part
}
```

This function should 

- Take in a set of center xy coordinates, a long axis xy coordinates, a short axis xy coordinates, and a fill colour.
- Create a convex `polygon()` of 8 sides that resembles an oval, that is symmetric along the long axis (from centerxy to longxy) and the short axis (from centerxy to shortxy)
- The oval should not simply be a diamond, that would be four sides.

Test your function with the following code

```{r, eval=FALSE}
plot.new()
plot.window(xlim=c(-5,5), ylim=c(-5,5))
venn.oval(centerxy = c(0,0), longxy = c(2,-2), 
                 shortxy = c(1,1), col="#FFFFFF")
```

b) (4 marks) Make a four-way venn diagram function called

```{r, eval=FALSE}

venn4 = function(centerx = c(1,2,3,4), 
                 centery = c(0,1,1,0), cols = rep("#FFFFFF", 4))
{
  # Fill in this part
  
}
```

This function should 

- Call `venn.oval` four times, using the colours Cyan, Magenta, Yellow, and Black, all at 80/255 opacity.
- Use the hex codes for the colours
- Be arranged in such a way that all 16 possible overlaps (include 'none of the four ovals' and 'all of the four ovals') are on the screen.


Test your function with the following code

```{r, eval=FALSE}
plot.new()
plot.window(xlim=c(-5,5), ylim=c(-5,5))
venn4(centerx = c(1,2,3,4), centery = c(0,1,1,0),
      col=c(YOU FILL THIS PART)
```

